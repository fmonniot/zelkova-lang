use crate::tokenizer::{LexicalError, Token};
use crate::position::Position;
use crate::frontend::*;

grammar;

extern {
    type Location = Position;
    type Error = LexicalError;

    enum Token {
        "identifier" => Token::Identifier{ name: <String>},
        "integer" => Token::Integer { value: <i64> },
        "float" => Token::Float { value: <f64> },
        "char" => Token::Char { value: <char> },

        "\n" => Token::Newline,
        Indent => Token::Indent,
        Dedent => Token::Dedent,
        
        "(" => Token::LPar,
        ")" => Token::RPar,
        ":" => Token::Colon,
        "=" => Token::Equal,
        "," => Token::Comma,
        "->" => Token::Arrow,

        "module" => Token::Module,
        "exposing" => Token::Exposing,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
    }
}

// Building a macro which accumulate tokens of certain type
// which are separated by a comma
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Ident: Name = <"identifier"> => Name(<>);




// Expressions


Lit: Literal = {
    <"integer"> => Literal::Int(<>),
    <"float"> => Literal::Float(<>),
    <"char"> => Literal::Char(<>),
    // TODO boolean
};

// Base expression
AtomicExpr: Expression = {
    <id: Ident> =>
        Expression::Variable(id),

    <lit: Lit> =>
        Expression::Lit(lit),

    // <expr: AtomicExpr> "." <id: Ident> =>
    //     Expression::Projection(Box::new(expr), id),
    // 
    // "(" <elems: CommaSlice<Expr>> ")" =>
    //     Expression::Tuple { elems },
    // 
    // "[" <elems: CommaSlice<Expr>> "]" => 
    //     Expression::List { elems },

    // TODO record
};


// Applicative expression
AppExpr = {
    AtomicExpr,

    // Might be a bug here, as expr can be a lit, and, well, a literal
    // doesn't apply anything. or does it ?
    <expr: AtomicExpr> <arg: Expr> =>
        Expression::Application(Box::new(expr), Box::new(arg)),
};

// TODO LambdaExpr which take AppExpr as a branch and replace AppExpr in Expr

Expr = {
    AppExpr,

    "if" <pred: Expr> "then" <if_true: Expr> "else" <if_false: Expr> =>
        todo!(),

    // TODO let binding: type  (FunType)
    // TODO let binding: value (BindGroup)

    // TODO pattern matching
};

// Declarations

AtomicType: Type = {
    <name:Ident> => Type::Named(name),
}

Type: Type = {
    AtomicType,
    
    "(" <tpe1:Type> ")" "->" <tpe2:Type> => Type::curry_arrow(tpe1, tpe2),

    <name:AtomicType> "->" <tpe:Type> => Type::curry_arrow(name, tpe),
}

// TODO Support function types (paired with pattern matching in bind groups)
FunType: FunType = <name:Ident> ":" <tpe:Type> => {
    FunType { name, tpe }
};

// TODO Pattern matching needs to be fleshed out :)
BindGroup: BindGroup = <name:Ident> "=" <expr:Expr> => {
    BindGroup {
        name,
        patterns: vec![
            Match {
                pattern: vec![],
                body: expr
            }
        ]
    }
};


Decl: Declaration = {
    <BindGroup> => Declaration::Function(<>),
    <FunType> => Declaration::FunctionType(<>),
};

// Module

FileLine: Option<Declaration> = {
    <Decl> "\n" => Some(<>),
    "\n" => None,
};

// entry point for our parser, a source file always start by
// declaring the module
pub Module: Module = "module" <name: Ident> "exposing" "(" <exposing:Comma<Ident>> ")" "\n" <lines:FileLine*> => {
    Module {
        name,
        exposing,
        declarations: lines.into_iter().flatten().collect(),
    }
};

// TODO Maybe something for the REPL. Might just be Decl.
