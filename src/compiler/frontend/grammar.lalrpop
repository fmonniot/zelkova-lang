use crate::compiler::position::Position;
use crate::compiler::frontend::tokenizer::{LexicalError, Token};
use crate::compiler::frontend::*;

grammar;

extern {
    type Location = Position;
    type Error = LexicalError;

    enum Token {
        // literals
        "identifier" => Token::Identifier{ name: <String>},
        "integer"    => Token::Integer { value: <i64> },
        "float"      => Token::Float { value: <f64> },
        "char"       => Token::Char { value: <char> },

        // layout
        "\n"   => Token::Newline,
        Indent => Token::Indent,
        Dedent => Token::Dedent,
        
        // Symbol
        "("  => Token::LPar,
        ")"  => Token::RPar,
        ":"  => Token::Colon,
        "."  => Token::Dot,
        ".." => Token::DotDot,
        "="  => Token::Equal,
        ","  => Token::Comma,
        "->" => Token::Arrow,
        "+"  => Token::Plus,
        "|"  => Token::Pipe,

        // keywords
        "module"   => Token::Module,
        "exposing" => Token::Exposing,
        "import"   => Token::Import,
        "as"       => Token::As,
        "type"     => Token::Type,
        "case"     => Token::Case,
        "of"       => Token::Of,
        "if"       => Token::If,
        "then"     => Token::Then,
        "else"     => Token::Else,
    }
}

// Building a macro which accumulate tokens of certain type
// which are separated by a comma
Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
}

Ident: Name = <"identifier"> => Name(<>);




// Expressions


Lit: Literal = {
    <"integer"> => Literal::Int(<>),
    <"float"> => Literal::Float(<>),
    <"char"> => Literal::Char(<>),
    // TODO boolean
};

InfixOp: Name = {
    "+" => Name("plus".to_string()),
}

// Base expression
AtomicExpr: Expression = {
    <id: Ident> =>
        Expression::Variable(id),

    <lit: Lit> =>
        Expression::Lit(lit),

    // <expr: AtomicExpr> "." <id: Ident> =>
    //     Expression::Projection(Box::new(expr), id),
    // 

    "(" <elems: Comma<Expr>> ")" => {
        match elems.len() {
            // This isn't a tuple by a parenthesis around an expression
            1 => elems.first().unwrap().clone(),
            _ => Expression::Tuple(Box::new(elems))
        }
    },
    
    // "[" <elems: CommaSlice<Expr>> "]" => 
    //     Expression::List { elems },

    // TODO record
};


// Applicative expression
AppExpr = {
    AtomicExpr,

    // Might be a bug here, as expr can be a lit, and, well, a literal
    // doesn't apply anything. or does it ?
    <expr: AppExpr> <arg: AtomicExpr> =>
        Expression::Application(Box::new(expr), Box::new(arg)),
};

InfixExpr = {
    AppExpr,

    // TODO LambdaExpr which take AppExpr as a branch and replace AppExpr in Expr

    <lhs: AppExpr> <op: InfixOp> <rhs: InfixExpr> => {
        Expression::Application(
            Box::new(Expression::Application(
                Box::new(Expression::Variable(op)),
                Box::new(lhs),
            )),
            Box::new(rhs),
        )
    }
}


Expr = {
    InfixExpr,

    "if" <pred: Expr> "then" <if_true: Expr> "else" <if_false: Expr> =>
        todo!(),

    // TODO let binding: type  (FunType)
    // TODO let binding: value (BindGroup)

    // TODO pattern matching
};

// Declarations

AtomicType: Type = {
    <name:Ident> => Type::Named(name),
}

Type: Type = {
    AtomicType,
    
    "(" <tpe1:Type> ")" "->" <tpe2:Type> => Type::curry_arrow(tpe1, tpe2),

    <name:AtomicType> "->" <tpe:Type> => Type::curry_arrow(name, tpe),
}

// TODO Support function types (paired with pattern matching in bind groups)
FunType: FunType = <name:Ident> ":" <tpe:Type> => {
    FunType { name, tpe }
};

// TODO Pattern matching needs to be fleshed out :)
BindGroup: BindGroup = <name:Ident> "=" <expr:Expr> => {
    BindGroup {
        name,
        patterns: vec![
            Match {
                pattern: vec![],
                body: expr
            }
        ]
    }
};

Import:Import = {
    "import" <name: Ident> <alias: ("as" <Ident>)?> <exposing: ("exposing" <Exposing>)?> => {
        let exposing = exposing.unwrap_or_else(|| Exposing::Explicit(vec![]));

        Import {
            name,
            alias,
            exposing,
        }
    }
}


Decl: Declaration = {
    <BindGroup> => Declaration::Function(<>),
    <FunType> => Declaration::FunctionType(<>),
    <Import> => Declaration::Import(<>),
};

// Module

FileLine: Option<Declaration> = {
    <Decl> "\n" => Some(<>),
    "\n" => None,
};

Exposed: Exposed = {
    // TODO Most operators have explicit tokens, which might
    // or might not be a good thing after all.
    "(" <InfixOp> ")" => Exposed::Operator(<>),

    <i:Ident> => {
        if i.is_type() {
            Exposed::Upper(i, Privacy::Private)
        } else {
            Exposed::Lower(i)
        }
    },

    <i:Ident> "(" ".." ")" => {
        // TODO Restrict that to Ident with upper case first letter
        Exposed::Upper(i, Privacy::Public)
    },
};

MultiLineExposedInner: Exposed = "," <Exposed> => <>;

MultiLineExposed: Vec<Exposed> = "\n" Indent "," <es:Comma<Exposed>> => <>;

Exposing: Exposing = {
    "(" ".." ")" => Exposing::Open,
    "(" <e: Comma<Exposed>> ")" => Exposing::Explicit(<>),
    "\n" Indent "(" <e1: Exposed> <e: MultiLineExposed*> "\n" Indent ")" => {
        let mut explicits = vec![e1];
        explicits.extend(e.into_iter().flatten());
        
        Exposing::Explicit(explicits)
    }
};

// entry point for our parser, a source file always start by
// declaring the module
pub Module: Module = "module" <name: Ident> "exposing" <exposing:Exposing> "\n" <lines:FileLine*> => {
    Module {
        name,
        exposing,
        declarations: lines.into_iter().flatten().collect(),
    }
};

// TODO Maybe something for the REPL. Might just be Decl.
